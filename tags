!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ARPHRD_ETHER	include/arp.h	8;"	d
ARPOP_REPLY	include/arp.h	11;"	d
ARPOP_REQUEST	include/arp.h	10;"	d
ARP_ENTRY_TIMEOUT	include/arpcache.h	11;"	d
ARP_REQUEST_MAX_RETRIES	include/arpcache.h	12;"	d
BE_IP_FMT_STR	include/ip.h	61;"	d
BUF_SIZE	tcp_apps.c	8;"	d	file:
CC	Makefile	/^CC = gcc$/;"	m
CFLAGS	Makefile	/^CFLAGS = -g -Wall -Iinclude -std=gnu99$/;"	m
DEBUG	include/log.h	/^enum log_level { DEBUG = 0, INFO, WARNING, ERROR };$/;"	e	enum:log_level
DEFAULT_TTL	include/ip.h	45;"	d
ERROR	include/log.h	/^enum log_level { DEBUG = 0, INFO, WARNING, ERROR };$/;"	e	enum:log_level
ETHER_HDR_SIZE	include/ether.h	20;"	d
ETH_ALEN	include/ether.h	6;"	d
ETH_FRAME_LEN	include/ether.h	7;"	d
ETH_P_ALL	include/ether.h	10;"	d
ETH_P_ARP	include/ether.h	12;"	d
ETH_P_IP	include/ether.h	11;"	d
HASH_16BITS	include/hash.h	7;"	d
HASH_8BITS	include/hash.h	6;"	d
HDRS	Makefile	/^HDRS = .\/include\/*.h$/;"	m
HOST_IP_FMT_STR	include/ip.h	69;"	d
HOST_IP_FMT_STR	include/ip.h	71;"	d
ICMP_COPIED_DATA_LEN	include/icmp.h	17;"	d
ICMP_DEST_UNREACH	include/icmp.h	21;"	d
ICMP_ECHOREPLY	include/icmp.h	20;"	d
ICMP_ECHOREQUEST	include/icmp.h	19;"	d
ICMP_EXC_TTL	include/icmp.h	29;"	d
ICMP_HDR_SIZE	include/icmp.h	16;"	d
ICMP_HOST_UNREACH	include/icmp.h	26;"	d
ICMP_NET_UNREACH	include/icmp.h	25;"	d
ICMP_TIME_EXCEEDED	include/icmp.h	22;"	d
INFO	include/log.h	/^enum log_level { DEBUG = 0, INFO, WARNING, ERROR };$/;"	e	enum:log_level
IPPROTO_ICMP	include/ip.h	13;"	d
IPPROTO_OSPFv2	include/ip.h	24;"	d
IPPROTO_TCP	include/ip.h	17;"	d
IPPROTO_UDP	include/ip.h	21;"	d
IP_BASE_HDR_SIZE	include/ip.h	48;"	d
IP_DATA	include/ip.h	50;"	d
IP_DF	include/ip.h	46;"	d
IP_FMT	include/ip.h	55;"	d
IP_HDR_SIZE	include/ip.h	49;"	d
LD	Makefile	/^LD = gcc$/;"	m
LDFLAGS	Makefile	/^LDFLAGS = -L. -Wl,--hash-style=sysv$/;"	m
LE_IP_FMT_STR	include/ip.h	56;"	d
LIBS	Makefile	/^LIBS = -lipstack -lpthread 			#-lm 连接math库$/;"	m
MAX_ARP_SIZE	include/arpcache.h	10;"	d
MSS	include/my.h	13;"	d
NET_IP_FMT_STR	include/ip.h	66;"	d
OBJS	Makefile	/^OBJS = $(patsubst %.c,%.o,$(SRCS))$/;"	m
PORT_MAX	include/tcp_sock.h	15;"	d
PORT_MIN	include/tcp_sock.h	14;"	d
SRCS	Makefile	/^SRCS = ip.c main.c tcp.c tcp_apps.c tcp_in.c tcp_out.c tcp_sock.c tcp_timer.c$/;"	m
TARGET	Makefile	/^TARGET = tcp_stack$/;"	m
TCPTopo	tcp_topo.py	/^class TCPTopo(Topo):$/;"	c
TCPTopo	tcp_topo_loss.py	/^class TCPTopo(Topo):$/;"	c
TCP_ACK	include/tcp.h	33;"	d
TCP_BASE_HDR_SIZE	include/tcp.h	41;"	d
TCP_CCWR	include/tcp.h	/^     TCP_COPEN, TCP_CLOSS, TCP_CDISORDER, TCP_CCWR, TCP_CRECOVERY,TCP_CPR$/;"	e	enum:tcp_cstate
TCP_CDISORDER	include/tcp.h	/^     TCP_COPEN, TCP_CLOSS, TCP_CDISORDER, TCP_CCWR, TCP_CRECOVERY,TCP_CPR$/;"	e	enum:tcp_cstate
TCP_CLOSED	include/tcp.h	/^enum tcp_state { TCP_CLOSED, TCP_LISTEN, TCP_SYN_RECV, TCP_SYN_SENT, \\$/;"	e	enum:tcp_state
TCP_CLOSE_WAIT	include/tcp.h	/^	TCP_ESTABLISHED, TCP_CLOSE_WAIT, TCP_LAST_ACK, TCP_FIN_WAIT_1, \\$/;"	e	enum:tcp_state
TCP_CLOSING	include/tcp.h	/^	TCP_FIN_WAIT_2, TCP_CLOSING, TCP_TIME_WAIT };$/;"	e	enum:tcp_state
TCP_CLOSS	include/tcp.h	/^     TCP_COPEN, TCP_CLOSS, TCP_CDISORDER, TCP_CCWR, TCP_CRECOVERY,TCP_CPR$/;"	e	enum:tcp_cstate
TCP_COPEN	include/tcp.h	/^     TCP_COPEN, TCP_CLOSS, TCP_CDISORDER, TCP_CCWR, TCP_CRECOVERY,TCP_CPR$/;"	e	enum:tcp_cstate
TCP_CPR	include/tcp.h	/^     TCP_COPEN, TCP_CLOSS, TCP_CDISORDER, TCP_CCWR, TCP_CRECOVERY,TCP_CPR$/;"	e	enum:tcp_cstate
TCP_CRECOVERY	include/tcp.h	/^     TCP_COPEN, TCP_CLOSS, TCP_CDISORDER, TCP_CCWR, TCP_CRECOVERY,TCP_CPR$/;"	e	enum:tcp_cstate
TCP_DEFAULT_WINDOW	include/tcp.h	44;"	d
TCP_ESTABLISHED	include/tcp.h	/^	TCP_ESTABLISHED, TCP_CLOSE_WAIT, TCP_LAST_ACK, TCP_FIN_WAIT_1, \\$/;"	e	enum:tcp_state
TCP_FIN	include/tcp.h	29;"	d
TCP_FIN_WAIT_1	include/tcp.h	/^	TCP_ESTABLISHED, TCP_CLOSE_WAIT, TCP_LAST_ACK, TCP_FIN_WAIT_1, \\$/;"	e	enum:tcp_state
TCP_FIN_WAIT_2	include/tcp.h	/^	TCP_FIN_WAIT_2, TCP_CLOSING, TCP_TIME_WAIT };$/;"	e	enum:tcp_state
TCP_HASH_MASK	include/tcp_hash.h	9;"	d
TCP_HASH_SIZE	include/tcp_hash.h	8;"	d
TCP_HDR_OFFSET	include/tcp.h	40;"	d
TCP_HDR_SIZE	include/tcp.h	42;"	d
TCP_LAST_ACK	include/tcp.h	/^	TCP_ESTABLISHED, TCP_CLOSE_WAIT, TCP_LAST_ACK, TCP_FIN_WAIT_1, \\$/;"	e	enum:tcp_state
TCP_LISTEN	include/tcp.h	/^enum tcp_state { TCP_CLOSED, TCP_LISTEN, TCP_SYN_RECV, TCP_SYN_SENT, \\$/;"	e	enum:tcp_state
TCP_MAX_BACKLOG	include/tcp_sock.h	56;"	d
TCP_MSL	include/tcp_timer.h	22;"	d
TCP_PSH	include/tcp.h	32;"	d
TCP_RETRANS_INTERVAL_INITIAL	include/tcp_timer.h	24;"	d
TCP_RST	include/tcp.h	31;"	d
TCP_SYN	include/tcp.h	30;"	d
TCP_SYN_RECV	include/tcp.h	/^enum tcp_state { TCP_CLOSED, TCP_LISTEN, TCP_SYN_RECV, TCP_SYN_SENT, \\$/;"	e	enum:tcp_state
TCP_SYN_SENT	include/tcp.h	/^enum tcp_state { TCP_CLOSED, TCP_LISTEN, TCP_SYN_RECV, TCP_SYN_SENT, \\$/;"	e	enum:tcp_state
TCP_TIMER_SCAN_INTERVAL	include/tcp_timer.h	21;"	d
TCP_TIMEWAIT_TIMEOUT	include/tcp_timer.h	23;"	d
TCP_TIME_WAIT	include/tcp.h	/^	TCP_FIN_WAIT_2, TCP_CLOSING, TCP_TIME_WAIT };$/;"	e	enum:tcp_state
TCP_URG	include/tcp.h	34;"	d
WARNING	include/log.h	/^enum log_level { DEBUG = 0, INFO, WARNING, ERROR };$/;"	e	enum:log_level
_MY_H_	include/my.h	2;"	d
__ARPCACHE_H__	include/arpcache.h	2;"	d
__ARP_H__	include/arp.h	2;"	d
__ASYNC_WAIT_H__	include/async_wait.h	2;"	d
__BASE_H__	include/base.h	2;"	d
__CHECKSUM_H__	include/checksum.h	2;"	d
__ETHER_H__	include/ether.h	2;"	d
__HASH_H__	include/hash.h	2;"	d
__ICMP_H__	include/icmp.h	2;"	d
__IP_H__	include/ip.h	2;"	d
__LIST_H__	include/list.h	2;"	d
__LOG_H__	include/log.h	2;"	d
__PACKET_H__	include/packet.h	2;"	d
__RING_BUFFER_H__	include/ring_buffer.h	2;"	d
__RTABLE_H__	include/rtable.h	2;"	d
__SYNCH_WAIT_H__	include/synch_wait.h	2;"	d
__TCP_APPS_H__	include/tcp_apps.h	2;"	d
__TCP_HASH_H__	include/tcp_hash.h	2;"	d
__TCP_H__	include/tcp.h	2;"	d
__TCP_SOCK_H__	include/tcp_sock.h	2;"	d
__TCP_TIMER_H__	include/tcp_timer.h	2;"	d
__TYPES_H__	include/types.h	2;"	d
accept_backlog	include/tcp_sock.h	/^	int accept_backlog;$/;"	m	struct:tcp_sock
accept_queue	include/tcp_sock.h	/^	struct list_head accept_queue;$/;"	m	struct:tcp_sock	typeref:struct:tcp_sock::list_head
ack	include/tcp.h	/^	u32 ack;			\/\/ acknowledgement number$/;"	m	struct:tcphdr
ack	include/tcp.h	/^	u32 ack;		\/\/ ack number in tcp header$/;"	m	struct:tcp_cb
added	include/arpcache.h	/^	time_t added;		\/\/ the time when this entry is inserted$/;"	m	struct:arp_cache_entry
adv_wnd	include/tcp_sock.h	/^	u16 adv_wnd;$/;"	m	struct:tcp_sock
alloc_packet_link_node	include/my.h	/^static inline struct packet_link_node* alloc_packet_link_node(int len)$/;"	f
alloc_ring_buffer	include/ring_buffer.h	/^static inline struct ring_buffer *alloc_ring_buffer(int size)$/;"	f
alloc_tcp_sock	tcp_sock.c	/^struct tcp_sock *alloc_tcp_sock()$/;"	f
alloc_wait_struct	include/async_wait.h	/^static inline struct async_wait *alloc_wait_struct()$/;"	f
alloc_wait_struct	include/synch_wait.h	/^static inline struct synch_wait *alloc_wait_struct()$/;"	f
allowed_send	include/tcp_sock.h	/^    int allowed_send;$/;"	m	struct:tcp_sock
arp_cache_entry	include/arpcache.h	/^struct arp_cache_entry {$/;"	s
arp_hln	include/arp.h	/^    u8	arp_hln;		\/\/ length of hardware address, should be 6$/;"	m	struct:ether_arp
arp_hrd	include/arp.h	/^    u16 arp_hrd;		\/\/ format of hardware address, should be 0x01$/;"	m	struct:ether_arp
arp_op	include/arp.h	/^    u16 arp_op;			\/\/ ARP opcode (command)$/;"	m	struct:ether_arp
arp_pln	include/arp.h	/^    u8	arp_pln;		\/\/ length of protocol address, should be 4$/;"	m	struct:ether_arp
arp_pro	include/arp.h	/^    u16 arp_pro;		\/\/ format of protocol address, should be 0x0800$/;"	m	struct:ether_arp
arp_req	include/arpcache.h	/^struct arp_req {$/;"	s
arp_sha	include/arp.h	/^	u8	arp_sha[ETH_ALEN];	\/\/ sender hardware address$/;"	m	struct:ether_arp
arp_spa	include/arp.h	/^	u32	arp_spa;		\/\/ sender protocol address$/;"	m	struct:ether_arp
arp_tha	include/arp.h	/^	u8	arp_tha[ETH_ALEN];	\/\/ target hardware address$/;"	m	struct:ether_arp
arp_tpa	include/arp.h	/^	u32	arp_tpa;		\/\/ target protocol address$/;"	m	struct:ether_arp
arpcache_t	include/arpcache.h	/^} arpcache_t;$/;"	t	typeref:struct:__anon4
async_wait	include/async_wait.h	/^struct async_wait {$/;"	s
backlog	include/tcp_sock.h	/^	int backlog;$/;"	m	struct:tcp_sock
bind_hash_list	include/tcp_sock.h	/^	struct list_head bind_hash_list;$/;"	m	struct:tcp_sock	typeref:struct:tcp_sock::list_head
bind_table	include/tcp_hash.h	/^	struct list_head bind_table[TCP_HASH_SIZE];$/;"	m	struct:tcp_hash_table	typeref:struct:tcp_hash_table::list_head
buf	include/ring_buffer.h	/^	char buf[0];$/;"	m	struct:ring_buffer
build	tcp_topo.py	/^    def build(self):$/;"	m	class:TCPTopo
build	tcp_topo_loss.py	/^    def build(self):$/;"	m	class:TCPTopo
cached_packets	include/arpcache.h	/^	struct list_head cached_packets;	\/\/ pending packets$/;"	m	struct:arp_req	typeref:struct:arp_req::list_head
cached_pkt	include/arpcache.h	/^struct cached_pkt {$/;"	s
checksum	include/checksum.h	/^static inline u16 checksum(u16 *buf, int nbytes, u32 sum)$/;"	f
checksum	include/icmp.h	/^	u16	checksum;			$/;"	m	struct:icmphdr
checksum	include/ip.h	/^    u16 checksum;						\/\/ checksum of ip header$/;"	m	struct:iphdr
checksum	include/tcp.h	/^	u16 checksum;		\/\/ checksum$/;"	m	struct:tcphdr
client	tcp_stack.py	/^def client(ip, port):$/;"	f
code	include/icmp.h	/^	u8	code;				\/\/ icmp code$/;"	m	struct:icmphdr
cond	include/async_wait.h	/^	pthread_cond_t cond;$/;"	m	struct:async_wait
cond	include/synch_wait.h	/^	pthread_cond_t cond;		\/\/ condition variable to synch$/;"	m	struct:synch_wait
copy_flag_str	tcp.c	/^static int copy_flag_str(u8 flags, int flag, char *buf, int start, $/;"	f	file:
cstate	include/tcp_sock.h	/^    int cstate;$/;"	m	struct:tcp_sock
cwnd	include/tcp_sock.h	/^	float cwnd;$/;"	m	struct:tcp_sock
daddr	include/ip.h	/^    u32 daddr;							\/\/ destination ip address$/;"	m	struct:iphdr
daddr	include/tcp.h	/^	u32 daddr;		\/\/ source port of the packet$/;"	m	struct:tcp_cb
dead	include/async_wait.h	/^	int dead;$/;"	m	struct:async_wait
dead	include/synch_wait.h	/^	int dead;					\/\/ whether dead$/;"	m	struct:synch_wait
dest	include/rtable.h	/^	u32 dest;				\/\/ destination ip address (could be network or host)$/;"	m	struct:__anon1
dport	include/tcp.h	/^	u16 dport;		\/\/ dest port of the packet$/;"	m	struct:tcp_cb
dport	include/tcp.h	/^	u16 dport;		\/\/ destination port$/;"	m	struct:tcphdr
enable	include/tcp_timer.h	/^	int enable;$/;"	m	struct:tcp_timer
entries	include/arpcache.h	/^	struct arp_cache_entry entries[MAX_ARP_SIZE];	\/\/ IP->max mapping entries$/;"	m	struct:__anon4	typeref:struct:__anon4::arp_cache_entry
established_table	include/tcp_hash.h	/^	struct list_head established_table[TCP_HASH_SIZE];$/;"	m	struct:tcp_hash_table	typeref:struct:tcp_hash_table::list_head
ether_arp	include/arp.h	/^struct ether_arp {$/;"	s
ether_dhost	include/ether.h	/^	u8 ether_dhost[ETH_ALEN];			\/\/ destination mac address$/;"	m	struct:ether_header
ether_header	include/ether.h	/^struct ether_header {$/;"	s
ether_shost	include/ether.h	/^	u8 ether_shost[ETH_ALEN];			\/\/ source mac address$/;"	m	struct:ether_header
ether_type	include/ether.h	/^	u16 ether_type;						\/\/ protocol format$/;"	m	struct:ether_header
fd	include/base.h	/^	int fd;						\/\/ file descriptor for receiving & sending $/;"	m	struct:__anon3
fd_to_iface	main.c	/^static iface_info_t *fd_to_iface(int fd)$/;"	f	file:
fds	include/base.h	/^	struct pollfd *fds;				\/\/ structure used to poll packets among $/;"	m	struct:__anon2	typeref:struct:__anon2::pollfd
find_available_ifaces	main.c	/^static void find_available_ifaces()$/;"	f	file:
flags	include/rtable.h	/^	int flags;				\/\/ flags (could be omitted here)$/;"	m	struct:__anon1
flags	include/tcp.h	/^	u8 flags;		\/\/ flags in tcp header$/;"	m	struct:tcp_cb
flags	include/tcp.h	/^	u8 flags;$/;"	m	struct:tcphdr
frag_off	include/ip.h	/^    u16 frag_off;						\/\/ the offset of ip fragment$/;"	m	struct:iphdr
free_packet_link_node	include/my.h	/^static inline void free_packet_link_node(struct packet_link_node *pkt_node) $/;"	f
free_ring_buffer	include/ring_buffer.h	/^static inline void free_ring_buffer(struct ring_buffer *rbuf)$/;"	f
free_tcp_sock	tcp_sock.c	/^void free_tcp_sock(struct tcp_sock *tsk)$/;"	f
free_wait_struct	include/async_wait.h	/^static inline void free_wait_struct(struct async_wait *wait)$/;"	f
free_wait_struct	include/synch_wait.h	/^static inline void free_wait_struct(struct synch_wait *wait)$/;"	f
greater_or_equal_32b	include/tcp.h	12;"	d
greater_than_32b	include/tcp.h	13;"	d
gw	include/rtable.h	/^	u32 gw;					\/\/ ip address of next hop (will be 0 if dest is in $/;"	m	struct:__anon1
handle_ip_packet	ip.c	/^void handle_ip_packet(iface_info_t *iface, char *packet, int len)$/;"	f
handle_packet	main.c	/^void handle_packet(iface_info_t *iface, char *packet, int len)$/;"	f
handle_tcp_packet	tcp.c	/^void handle_tcp_packet(char *packet, struct iphdr *ip, struct tcphdr *tcp)$/;"	f
hash16	include/hash.h	/^static inline u16 hash16(char *buf, int len)$/;"	f
hash8	include/hash.h	/^static inline u8 hash8(char *buf, int len)$/;"	f
hash_list	include/tcp_sock.h	/^	struct list_head hash_list;$/;"	m	struct:tcp_sock	typeref:struct:tcp_sock::list_head
head	include/ring_buffer.h	/^	int head;		\/\/ read from head$/;"	m	struct:ring_buffer
icmp_checksum	include/icmp.h	/^static inline u16 icmp_checksum(struct icmphdr *icmp, int len)$/;"	f
icmp_identifier	include/icmp.h	/^	u16 icmp_identifier;	\/\/ icmp identifier, used in icmp echo request$/;"	m	struct:icmphdr
icmp_sequence	include/icmp.h	/^	u16 icmp_sequence;		\/\/ icmp sequence, used in icmp echo request$/;"	m	struct:icmphdr
icmphdr	include/icmp.h	/^struct icmphdr {$/;"	s
id	include/ip.h	/^    u16 id;								\/\/ ip identifier$/;"	m	struct:iphdr
if_name	include/rtable.h	/^	char if_name[16];		\/\/ name of the interface$/;"	m	struct:__anon1
iface	include/arpcache.h	/^	iface_info_t *iface;	\/\/ the interface that will send the pending packets$/;"	m	struct:arp_req
iface	include/rtable.h	/^	iface_info_t *iface;	\/\/ pointer to the interface structure$/;"	m	struct:__anon1
iface_info_t	include/base.h	/^} iface_info_t;$/;"	t	typeref:struct:__anon3
iface_list	include/base.h	/^	struct list_head iface_list;	\/\/ the list of interfaces$/;"	m	struct:__anon2	typeref:struct:__anon2::list_head
ihl	include/ip.h	/^    unsigned int ihl:4;					\/\/ length of ip header$/;"	m	struct:iphdr
index	include/base.h	/^	int index;					\/\/ the index (unique ID) of this interface$/;"	m	struct:__anon3
inflight	include/tcp_sock.h	/^    int inflight;$/;"	m	struct:tcp_sock
init_all_ifaces	main.c	/^void init_all_ifaces()$/;"	f
init_list_head	include/list.h	/^static inline void init_list_head(struct list_head *list)$/;"	f
init_tcp_stack	tcp_sock.c	/^void init_tcp_stack()$/;"	f
init_timer	tcp_timer.c	/^void init_timer(struct tcp_timer *timer, int type) $/;"	f
init_ustack	main.c	/^void init_ustack()$/;"	f
instance	main.c	/^ustack_t *instance;$/;"	v
ip	include/base.h	/^	u32 ip;						\/\/ ip address of this interface$/;"	m	struct:__anon3
ip	include/tcp.h	/^	struct iphdr *ip;		\/\/ pointer to ip header$/;"	m	struct:tcp_cb	typeref:struct:tcp_cb::iphdr
ip	include/tcp_sock.h	/^	u32 ip;$/;"	m	struct:sock_addr
ip4	include/arpcache.h	/^	u32 ip4;				\/\/ destination ip address$/;"	m	struct:arp_req
ip4	include/arpcache.h	/^	u32 ip4; 			\/\/ destination ip address, stored in host byte order$/;"	m	struct:arp_cache_entry
ip_checksum	include/ip.h	/^static inline u16 ip_checksum(struct iphdr *hdr)$/;"	f
ip_str	include/base.h	/^	char ip_str[16];			\/\/ string of the ip address$/;"	m	struct:__anon3
iphdr	include/ip.h	/^struct iphdr {$/;"	s
is_tcp_seq_valid	tcp_in.c	/^static inline int is_tcp_seq_valid(struct tcp_sock *tsk, struct tcp_cb *cb)$/;"	f	file:
iss	include/tcp_sock.h	/^	u32 iss;$/;"	m	struct:tcp_sock
len	include/arpcache.h	/^	int len;				\/\/ the length of packet$/;"	m	struct:cached_pkt
len	include/my.h	/^   u32 len;$/;"	m	struct:packet_link_node
less_or_equal_32b	include/tcp.h	10;"	d
less_than_32b	include/tcp.h	11;"	d
list	include/arpcache.h	/^	struct list_head list;	$/;"	m	struct:arp_req	typeref:struct:arp_req::list_head
list	include/arpcache.h	/^	struct list_head list;$/;"	m	struct:cached_pkt	typeref:struct:cached_pkt::list_head
list	include/base.h	/^	struct list_head list;		\/\/ list node used to link all interfaces$/;"	m	struct:__anon3	typeref:struct:__anon3::list_head
list	include/my.h	/^   struct list_head list;$/;"	m	struct:packet_link_node	typeref:struct:packet_link_node::list_head
list	include/rtable.h	/^	struct list_head list;$/;"	m	struct:__anon1	typeref:struct:__anon1::list_head
list	include/tcp.h	/^	struct list_head list; 		\/\/modified$/;"	m	struct:tcp_cb	typeref:struct:tcp_cb::list_head
list	include/tcp_sock.h	/^	struct list_head list;$/;"	m	struct:tcp_sock	typeref:struct:tcp_sock::list_head
list	include/tcp_timer.h	/^	struct list_head list;$/;"	m	struct:tcp_timer	typeref:struct:tcp_timer::list_head
list_add_head	include/list.h	/^static inline void list_add_head(struct list_head *new, struct list_head *head)$/;"	f
list_add_tail	include/list.h	/^static inline void list_add_tail(struct list_head *new, struct list_head *head)$/;"	f
list_delete_entry	include/list.h	/^static inline void list_delete_entry(struct list_head *entry)$/;"	f
list_empty	include/list.h	12;"	d
list_entry	include/list.h	15;"	d
list_for_each_entry	include/list.h	19;"	d
list_for_each_entry_safe	include/list.h	25;"	d
list_head	include/list.h	/^struct list_head {$/;"	s
list_insert	include/list.h	/^static inline void list_insert(struct list_head *new,$/;"	f
listen_queue	include/tcp_sock.h	/^	struct list_head listen_queue;$/;"	m	struct:tcp_sock	typeref:struct:tcp_sock::list_head
listen_table	include/tcp_hash.h	/^	struct list_head listen_table[TCP_HASH_SIZE];$/;"	m	struct:tcp_hash_table	typeref:struct:tcp_hash_table::list_head
local	include/tcp_sock.h	/^	struct sock_addr local;$/;"	m	struct:tcp_sock	typeref:struct:tcp_sock::sock_addr
lock	include/arpcache.h	/^	pthread_mutex_t lock;				\/\/ each operation on arp cache should apply the lock first$/;"	m	struct:__anon4
lock	include/async_wait.h	/^	pthread_mutex_t lock;$/;"	m	struct:async_wait
lock	include/synch_wait.h	/^	pthread_mutex_t lock;		\/\/ mutex lock$/;"	m	struct:synch_wait
log	include/log.h	25;"	d
log_it	include/log.h	17;"	d
log_it	include/log.h	21;"	d
log_level	include/log.h	/^enum log_level { DEBUG = 0, INFO, WARNING, ERROR };$/;"	g
log_level_str	include/log.h	/^static const char *log_level_str[] = { "DEBUG", "INFO", "WARNING", "ERROR" };$/;"	v
mac	include/arpcache.h	/^	u8 mac[ETH_ALEN];	\/\/ mac address$/;"	m	struct:arp_cache_entry
mac	include/base.h	/^	u8	mac[ETH_ALEN];			\/\/ mac address of this interface$/;"	m	struct:__anon3
main	main.c	/^int main(int argc, char **argv)$/;"	f
mask	include/base.h	/^	u32 mask;					\/\/ ip mask of this interface$/;"	m	struct:__anon3
mask	include/rtable.h	/^	u32 mask;				\/\/ network mask of dest$/;"	m	struct:__anon1
max	tcp_in.c	47;"	d	file:
max	tcp_sock.c	18;"	d	file:
max	tcp_timer.c	12;"	d	file:
min	include/ring_buffer.h	56;"	d
name	include/base.h	/^	char name[16];				\/\/ name of this interface$/;"	m	struct:__anon3
net	tcp_topo.py	/^    net = Mininet(topo = topo, link = TCLink, controller = None) $/;"	v	class:TCPTopo
net	tcp_topo_loss.py	/^    net = Mininet(topo = topo, controller = None, link=TCLink) $/;"	v	class:TCPTopo
next	include/list.h	/^	struct list_head *next, *prev;$/;"	m	struct:list_head	typeref:struct:list_head::list_head
nifs	include/base.h	/^	int nifs;						\/\/ number of interfaces$/;"	m	struct:__anon2
notified	include/async_wait.h	/^	int notified;$/;"	m	struct:async_wait
notified	include/synch_wait.h	/^	int notified;				\/\/ whether ready to read\/write$/;"	m	struct:synch_wait
off	include/tcp.h	/^	u8 off:4;			\/\/ data offset$/;"	m	struct:tcphdr
open_device	main.c	/^int open_device(const char *dname)$/;"	f
packet	include/arpcache.h	/^	char *packet;			\/\/ packet$/;"	m	struct:cached_pkt
packet	include/my.h	/^   char *packet;$/;"	m	struct:packet_link_node
packet_link_node	include/my.h	/^struct packet_link_node $/;"	s
packet_to_ether_arp	include/arp.h	/^static inline struct ether_arp *packet_to_ether_arp(const char *packet)$/;"	f
packet_to_ip_hdr	include/ip.h	/^static inline struct iphdr *packet_to_ip_hdr(const char *packet)$/;"	f
packet_to_tcp_hdr	include/tcp.h	/^static inline struct tcphdr *packet_to_tcp_hdr(char *packet)$/;"	f
parent	include/tcp_sock.h	/^	struct tcp_sock *parent;$/;"	m	struct:tcp_sock	typeref:struct:tcp_sock::tcp_sock
payload	include/tcp.h	/^	char *payload;		\/\/ pointer to tcp data$/;"	m	struct:tcp_cb
peer	include/tcp_sock.h	/^	struct sock_addr peer;$/;"	m	struct:tcp_sock	typeref:struct:tcp_sock::sock_addr
pl_len	include/tcp.h	/^	int pl_len;		\/\/ the length of tcp data$/;"	m	struct:tcp_cb
port	include/tcp_sock.h	/^	u16 port;$/;"	m	struct:sock_addr
prev	include/list.h	/^	struct list_head *next, *prev;$/;"	m	struct:list_head	typeref:struct:list_head::
protocol	include/ip.h	/^    u8 protocol;						\/\/ upper layer protocol, e.g. icmp, tcp, udp $/;"	m	struct:iphdr
rcv_buf	include/tcp_sock.h	/^	struct ring_buffer *rcv_buf;$/;"	m	struct:tcp_sock	typeref:struct:tcp_sock::ring_buffer
rcv_nxt	include/tcp_sock.h	/^	u32 rcv_nxt;$/;"	m	struct:tcp_sock
rcv_ofo_buf	include/tcp_sock.h	/^	struct list_head rcv_ofo_buf;$/;"	m	struct:tcp_sock	typeref:struct:tcp_sock::list_head
rcv_wnd	include/tcp_sock.h	/^	u16 rcv_wnd;$/;"	m	struct:tcp_sock
read_iface_info	main.c	/^int read_iface_info(iface_info_t *iface)$/;"	f
read_ring_buffer	include/ring_buffer.h	/^static inline int read_ring_buffer(struct ring_buffer *rbuf, char *buf, int size)$/;"	f
readfile	result.py	/^def readfile(filename):$/;"	f
recovery_point	include/tcp_sock.h	/^	u32 recovery_point;		$/;"	m	struct:tcp_sock
ref_cnt	include/tcp_sock.h	/^	int ref_cnt;$/;"	m	struct:tcp_sock
req_list	include/arpcache.h	/^	struct list_head req_list;			\/\/ the pending packet list$/;"	m	struct:__anon4	typeref:struct:__anon4::list_head
resend	include/my.h	/^static inline void resend(struct tcp_sock *tsk) $/;"	f
retrans_timer	include/tcp_sock.h	/^	struct tcp_timer retrans_timer;$/;"	m	struct:tcp_sock	typeref:struct:tcp_sock::tcp_timer
retranstimer_to_tcp_sock	include/tcp_timer.h	19;"	d
retries	include/arpcache.h	/^	int retries;			\/\/ number of retries$/;"	m	struct:arp_req
ring_buffer	include/ring_buffer.h	/^struct ring_buffer {$/;"	s
ring_buffer_empty	include/ring_buffer.h	/^static inline int ring_buffer_empty(struct ring_buffer *rbuf)$/;"	f
ring_buffer_free	include/ring_buffer.h	/^static inline int ring_buffer_free(struct ring_buffer *rbuf)$/;"	f
ring_buffer_full	include/ring_buffer.h	/^static inline int ring_buffer_full(struct ring_buffer *rbuf)$/;"	f
ring_buffer_used	include/ring_buffer.h	/^static inline int ring_buffer_used(struct ring_buffer *rbuf)$/;"	f
rp	include/tcp_sock.h	/^    u32 rp;$/;"	m	struct:tcp_sock
rt_entry_t	include/rtable.h	/^} rt_entry_t;$/;"	t	typeref:struct:__anon1
run_application	main.c	/^static void run_application(const char *basename, char **args, int n)$/;"	f	file:
rwnd	include/tcp.h	/^	u16 rwnd;			\/\/ receiving window$/;"	m	struct:tcphdr
rwnd	include/tcp.h	/^	u32 rwnd;		\/\/ receiving window in tcp header$/;"	m	struct:tcp_cb
saddr	include/ip.h	/^    u32 saddr;							\/\/ source ip address$/;"	m	struct:iphdr
saddr	include/tcp.h	/^	u32 saddr;		\/\/ source addr of the packet$/;"	m	struct:tcp_cb
send_buf	include/tcp_sock.h	/^	struct list_head send_buf;$/;"	m	struct:tcp_sock	typeref:struct:tcp_sock::list_head
sent	include/arpcache.h	/^	time_t sent;			\/\/ last time when arp request is sent$/;"	m	struct:arp_req
seq	include/my.h	/^   u32 seq;$/;"	m	struct:packet_link_node
seq	include/tcp.h	/^	u32 seq;			\/\/ sequence number$/;"	m	struct:tcphdr
seq	include/tcp.h	/^	u32 seq;		\/\/ sequence number in tcp header$/;"	m	struct:tcp_cb
seq_end	include/tcp.h	/^	u32 seq_end;		\/\/ seq + (SYN|FIN) + len(payload)$/;"	m	struct:tcp_cb
server	tcp_stack.py	/^def server(port):$/;"	f
size	include/ring_buffer.h	/^	int size;$/;"	m	struct:ring_buffer
sk_dip	include/tcp_sock.h	30;"	d
sk_dport	include/tcp_sock.h	31;"	d
sk_sip	include/tcp_sock.h	28;"	d
sk_sport	include/tcp_sock.h	29;"	d
sleep	include/async_wait.h	/^	int sleep;$/;"	m	struct:async_wait
sleep	include/synch_wait.h	/^	int sleep;					\/\/ whether others are waiting$/;"	m	struct:synch_wait
sleep_on	include/async_wait.h	/^static inline int sleep_on(struct async_wait *wait)$/;"	f
sleep_on	include/synch_wait.h	/^static inline int sleep_on(struct synch_wait *wait)$/;"	f
snd_nxt	include/tcp_sock.h	/^	u32 snd_nxt;$/;"	m	struct:tcp_sock
snd_una	include/tcp_sock.h	/^	u32 snd_una;$/;"	m	struct:tcp_sock
snd_wnd	include/tcp_sock.h	/^	int snd_wnd;$/;"	m	struct:tcp_sock
sock_addr	include/tcp_sock.h	/^struct sock_addr {$/;"	s
sport	include/tcp.h	/^	u16 sport;		\/\/ dest addr of the packet$/;"	m	struct:tcp_cb
sport	include/tcp.h	/^	u16 sport;		\/\/ source port $/;"	m	struct:tcphdr
ssthresh	include/tcp_sock.h	/^	u32 ssthresh;$/;"	m	struct:tcp_sock
state	include/tcp_sock.h	/^	int state;$/;"	m	struct:tcp_sock
synch_wait	include/synch_wait.h	/^struct synch_wait {$/;"	s
tail	include/ring_buffer.h	/^	int tail;		\/\/ write from tail$/;"	m	struct:ring_buffer
tcp	include/tcp.h	/^	struct tcphdr *tcp;		\/\/ pointer to tcp header$/;"	m	struct:tcp_cb	typeref:struct:tcp_cb::tcphdr
tcp_bind_hash	tcp_sock.c	/^static int tcp_bind_hash(struct tcp_sock *tsk)$/;"	f	file:
tcp_bind_sock_table	tcp_sock.c	23;"	d	file:
tcp_bind_unhash	tcp_sock.c	/^void tcp_bind_unhash(struct tcp_sock *tsk)$/;"	f
tcp_cb	include/tcp.h	/^struct tcp_cb {$/;"	s
tcp_cb_init	tcp.c	/^void tcp_cb_init(struct iphdr *ip, struct tcphdr *tcp, struct tcp_cb *cb)$/;"	f
tcp_cc_in	tcp_in.c	/^void tcp_cc_in(struct tcp_sock *tsk, struct tcp_cb *cb) {$/;"	f
tcp_checksum	include/tcp.h	/^static inline u16 tcp_checksum(struct iphdr *ip, struct tcphdr *tcp)$/;"	f
tcp_client	tcp_apps.c	/^void *tcp_client(void *arg)$/;"	f
tcp_copy_flags_to_str	tcp.c	/^void tcp_copy_flags_to_str(u8 flags, char buf[32])$/;"	f
tcp_cstate	include/tcp.h	/^enum tcp_cstate {$/;"	g
tcp_cwnd_plot_thread	tcp_timer.c	/^void *tcp_cwnd_plot_thread(void *arg)$/;"	f
tcp_data_len	include/my.h	/^   u32 tcp_data_len;$/;"	m	struct:packet_link_node
tcp_established_process	tcp_in.c	/^void tcp_established_process(struct tcp_sock *tsk, struct tcp_cb *cb, char *packet) {$/;"	f
tcp_established_sock_table	tcp_sock.c	21;"	d	file:
tcp_get_port	tcp_sock.c	/^static u16 tcp_get_port()$/;"	f	file:
tcp_hash	tcp_sock.c	/^int tcp_hash(struct tcp_sock *tsk)$/;"	f
tcp_hash_function	include/tcp_hash.h	/^static inline int tcp_hash_function(u32 saddr, u32 daddr, u16 sport, u16 dport)$/;"	f
tcp_hash_table	include/tcp_hash.h	/^struct tcp_hash_table {$/;"	s
tcp_init_hdr	tcp_out.c	/^static void tcp_init_hdr(struct tcphdr *tcp, u16 sport, u16 dport, u32 seq, u32 ack,$/;"	f	file:
tcp_listen_process	tcp_in.c	/^void tcp_listen_process(struct tcp_sock *tsk, struct tcp_cb *cb, char *packet) $/;"	f
tcp_listen_sock_table	tcp_sock.c	22;"	d	file:
tcp_new_iss	tcp.c	/^u32 tcp_new_iss()$/;"	f
tcp_port_in_use	tcp_sock.c	/^static int tcp_port_in_use(u16 sport)$/;"	f	file:
tcp_process	tcp_in.c	/^void tcp_process(struct tcp_sock *tsk, struct tcp_cb *cb, char *packet)$/;"	f
tcp_scan_timer_list	tcp_timer.c	/^void tcp_scan_timer_list()$/;"	f
tcp_send_control_packet	tcp_out.c	/^void tcp_send_control_packet(struct tcp_sock *tsk, u8 flags)$/;"	f
tcp_send_packet	tcp_out.c	/^void tcp_send_packet(struct tcp_sock *tsk, char *packet, int len) $/;"	f
tcp_send_reset	tcp_out.c	/^void tcp_send_reset(struct tcp_cb *cb)$/;"	f
tcp_server	tcp_apps.c	/^void *tcp_server(void *arg)$/;"	f
tcp_set_retrans_timer	tcp_timer.c	/^void tcp_set_retrans_timer(struct tcp_sock *tsk)$/;"	f
tcp_set_state	tcp_sock.c	/^inline void tcp_set_state(struct tcp_sock *tsk, int state)$/;"	f
tcp_set_timewait_timer	tcp_timer.c	/^void tcp_set_timewait_timer(struct tcp_sock *tsk)$/;"	f
tcp_sock	include/tcp_sock.h	/^struct tcp_sock {$/;"	s
tcp_sock_accept	tcp_sock.c	/^struct tcp_sock *tcp_sock_accept(struct tcp_sock *tsk)$/;"	f
tcp_sock_accept_dequeue	tcp_sock.c	/^inline struct tcp_sock *tcp_sock_accept_dequeue(struct tcp_sock *tsk)$/;"	f
tcp_sock_accept_enqueue	tcp_sock.c	/^inline void tcp_sock_accept_enqueue(struct tcp_sock *tsk)$/;"	f
tcp_sock_accept_queue_full	tcp_sock.c	/^inline int tcp_sock_accept_queue_full(struct tcp_sock *tsk)$/;"	f
tcp_sock_bind	tcp_sock.c	/^int tcp_sock_bind(struct tcp_sock *tsk, struct sock_addr *skaddr)$/;"	f
tcp_sock_close	tcp_sock.c	/^void tcp_sock_close(struct tcp_sock *tsk)$/;"	f
tcp_sock_connect	tcp_sock.c	/^int tcp_sock_connect(struct tcp_sock *tsk, struct sock_addr *skaddr)$/;"	f
tcp_sock_inc_ref_cnt	include/tcp_sock.h	/^static inline void tcp_sock_inc_ref_cnt(struct tcp_sock *tsk)$/;"	f
tcp_sock_listen	tcp_sock.c	/^int tcp_sock_listen(struct tcp_sock *tsk, int backlog)$/;"	f
tcp_sock_lookup	tcp_sock.c	/^struct tcp_sock *tcp_sock_lookup(struct tcp_cb *cb)$/;"	f
tcp_sock_lookup_established	tcp_sock.c	/^struct tcp_sock *tcp_sock_lookup_established(u32 saddr, u32 daddr, u16 sport, u16 dport)$/;"	f
tcp_sock_lookup_listen	tcp_sock.c	/^struct tcp_sock *tcp_sock_lookup_listen(u32 saddr, u16 sport)$/;"	f
tcp_sock_read	tcp_sock.c	/^int tcp_sock_read(struct tcp_sock *tsk, char *buf, int size)$/;"	f
tcp_sock_set_sport	tcp_sock.c	/^static int tcp_sock_set_sport(struct tcp_sock *tsk, u16 port)$/;"	f	file:
tcp_sock_table	tcp_sock.c	/^struct tcp_hash_table tcp_sock_table;$/;"	v	typeref:struct:tcp_hash_table
tcp_sock_write	tcp_sock.c	/^int tcp_sock_write(struct tcp_sock *tsk, char *buf, int size)$/;"	f
tcp_state	include/tcp.h	/^enum tcp_state { TCP_CLOSED, TCP_LISTEN, TCP_SYN_RECV, TCP_SYN_SENT, \\$/;"	g
tcp_state_str	tcp.c	/^const char *tcp_state_str[] = { "CLOSED", "LISTEN", "SYN_RECV",$/;"	v
tcp_state_to_str	include/tcp.h	/^static inline const char *tcp_state_to_str(int state)$/;"	f
tcp_syn_recv_process	tcp_in.c	/^void tcp_syn_recv_process(struct tcp_sock *tsk, struct tcp_cb *cb, char *packet) {$/;"	f
tcp_syn_sent_process	tcp_in.c	/^void tcp_syn_sent_process(struct tcp_sock *tsk, struct tcp_cb *cb, char *packet) $/;"	f
tcp_timer	include/tcp_timer.h	/^struct tcp_timer {$/;"	s
tcp_timer_thread	tcp_timer.c	/^void *tcp_timer_thread(void *arg)$/;"	f
tcp_unhash	tcp_sock.c	/^void tcp_unhash(struct tcp_sock *tsk)$/;"	f
tcp_unset_retrans_timer	tcp_timer.c	/^void tcp_unset_retrans_timer(struct tcp_sock *tsk)$/;"	f
tcp_update_window	tcp_in.c	/^static inline void tcp_update_window(struct tcp_sock *tsk, struct tcp_cb *cb)$/;"	f	file:
tcp_update_window_safe	tcp_in.c	/^static inline void tcp_update_window_safe(struct tcp_sock *tsk, struct tcp_cb *cb)$/;"	f	file:
tcphdr	include/tcp.h	/^struct tcphdr {$/;"	s
this_log_level	include/log.h	/^static enum log_level this_log_level = DEBUG;$/;"	v	typeref:enum:log_level
thread	include/arpcache.h	/^	pthread_t thread;					\/\/ the id of the arp cache sweeping thread$/;"	m	struct:__anon4
timeout	include/tcp_timer.h	/^	int timeout;	\/\/ in micro second$/;"	m	struct:tcp_timer
timer_list	tcp_timer.c	/^static struct list_head timer_list;$/;"	v	typeref:struct:list_head	file:
timewait	include/tcp_sock.h	/^	struct tcp_timer timewait;$/;"	m	struct:tcp_sock	typeref:struct:tcp_sock::tcp_timer
timewait_to_tcp_sock	include/tcp_timer.h	16;"	d
topo	tcp_topo.py	/^    topo = TCPTopo()$/;"	v	class:TCPTopo
topo	tcp_topo_loss.py	/^    topo = TCPTopo()$/;"	v	class:TCPTopo
tos	include/ip.h	/^    u8 tos;								\/\/ type of service (usually set to 0)$/;"	m	struct:iphdr
tot_len	include/ip.h	/^    u16 tot_len;						\/\/ total length of ip data$/;"	m	struct:iphdr
ttl	include/ip.h	/^    u8 ttl;								\/\/ ttl of ip packet$/;"	m	struct:iphdr
type	include/icmp.h	/^	u8	type;				\/\/ type of icmp message$/;"	m	struct:icmphdr
type	include/tcp_timer.h	/^	int type;	\/\/ time-wait: 0		retrans: 1$/;"	m	struct:tcp_timer
u16	include/types.h	/^typedef uint16_t u16;$/;"	t
u32	include/types.h	/^typedef uint32_t u32;$/;"	t
u64	include/types.h	/^typedef uint64_t u64;$/;"	t
u8	include/types.h	/^typedef uint8_t u8;$/;"	t
update_snd_buf	include/my.h	/^static inline void update_snd_buf(struct tcp_sock *tsk, struct tcp_cb *cb) $/;"	f
urp	include/tcp.h	/^	u16 urp;			\/\/ urgent pointer$/;"	m	struct:tcphdr
usage_and_exit	main.c	/^static void usage_and_exit(const char *basename)$/;"	f	file:
ustack_run	main.c	/^void ustack_run()$/;"	f
ustack_t	include/base.h	/^} ustack_t;$/;"	t	typeref:struct:__anon2
valid	include/arpcache.h	/^	int valid;			\/\/ whether this entry is valid (has not triggered the timeout)$/;"	m	struct:arp_cache_entry
version	include/ip.h	/^    unsigned int version:4;				\/\/ ip version $/;"	m	struct:iphdr
wait_accept	include/tcp_sock.h	/^	struct synch_wait *wait_accept;$/;"	m	struct:tcp_sock	typeref:struct:tcp_sock::synch_wait
wait_connect	include/tcp_sock.h	/^	struct synch_wait *wait_connect;$/;"	m	struct:tcp_sock	typeref:struct:tcp_sock::synch_wait
wait_exit	include/async_wait.h	/^static inline void wait_exit(struct async_wait *wait)$/;"	f
wait_exit	include/synch_wait.h	/^static inline void wait_exit(struct synch_wait *wait)$/;"	f
wait_init	include/async_wait.h	/^static inline void wait_init(struct async_wait *wait)$/;"	f
wait_init	include/synch_wait.h	/^static inline void wait_init(struct synch_wait *wait)$/;"	f
wait_recv	include/tcp_sock.h	/^	struct synch_wait *wait_recv;$/;"	m	struct:tcp_sock	typeref:struct:tcp_sock::synch_wait
wait_send	include/tcp_sock.h	/^	struct synch_wait *wait_send;$/;"	m	struct:tcp_sock	typeref:struct:tcp_sock::synch_wait
wake_up	include/async_wait.h	/^static inline int wake_up(struct async_wait *wait)$/;"	f
wake_up	include/synch_wait.h	/^static inline int wake_up(struct synch_wait *wait)$/;"	f
write_ring_buffer	include/ring_buffer.h	/^static inline void write_ring_buffer(struct ring_buffer *rbuf, char *buf, int size)$/;"	f
x2	include/tcp.h	/^	u8 x2:4;			\/\/ (unused)$/;"	m	struct:tcphdr
x_list	result.py	/^x_list = [t[0] for t in data_list]$/;"	v
y_list	result.py	/^y_list = [t[1] for t in data_list]$/;"	v
